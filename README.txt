In my card game, I used a few core design patterns to keep things organized and reusable. One of the main ones was the Flyweight pattern, which I used in the CardClass. Instead of giving every card its own separate image and size data, all cards share the same sprite sheet and dimensions. Suit, rank, and face-up status change between cards but the rest of them are shared. This approach saved memory and made the rendering logic more efficient and consistent. The State pattern was key in managing game interaction. For instance, the GrabberClass tracks whether a card is currently being held (dragging state) or if the user is just hovering. When a card is selected, the game effectively enters a "dragging" state, which alters how mouse inputs are processed. For example, like enabling card snapping or canceling the grab. I have implemented the observer pattern partially when using global flags like _G.needsReset act as observable state. The main update loop checks this state and triggers the needed actions. For example, when cards are moved from the waste pile, the game checks if the waste pile needs refilling. I have also implemented the singleton pattern through global variables. For example, _G.stockPile and _G.wastePile provide single access points to these objects which makes sure there is only one instance that's globally accessible. I implemented the Command pattern to support undo and reset functionality. Whenever an important game action occurs (like moving a card or recycling the stock), I deep-copy the current game state and push it on a history stack. When the player hits "undo", the previous game state is popped and restored. I also used this pattern to enable a reset feature that could be triggered when the game is won or no more moves are available. I have also implemented it through commands like DrawStockCommand, ResetStockCommand, and MoveCardCommand which encapsulate game actions.The CommandManager tracks history and handles undo operations. This has made the code more manageable. 

Postmortem:
One of the main problems in my Solitaire project was the size and complexity of the main.lua file. It grew to over 790 lines before new adding new features such as sound effects and additional buttons, handling everything from initialization to rendering to input processing, which made the code harder to navigate and maintain. Functions like love.load(), love.draw(), and love.mousepressed() became too long and tried to manage too many responsibilities. To address this, I began refactoring by moving related logic into separate files—such as card.lua, pile.lua, grabber.lua, and command.lua to improve modularity. I also broke large functions into smaller helper functions to make the code more readable and focused. While I didn’t fully eliminate all the complexity in main.lua, the refactoring efforts significantly improved organization and made it easier to debug and extend features. Overall, the refactoring made the game more maintainable.

Feedback:
I received feedback from Koushik Vasa, Sree Kolli, and Andrea Martinez. 
  Feedback: Code organization was good and use of object-oriented principles across classes like CardClass, PileClass, and GrabberClass. Suggested that the main.lua file was handling too many responsibilities and becoming difficult to manage. Mentioned the clean naming conventions, logical structure, and use of separate files for different components. Noted that card dimensions and some UI-related values were hardcoded, which could reduce flexibility later.
  Changes Made: I extracted core functionality into seperate modules and created a well-organized file structure with card.lua, pile.lua, grabber.lua, vector.lua, and command.lua. I developed a command system in command.lua file  that handles game actions like drawing cards, undo functionality, redo functionality, moving cards between piles, and resetting the stock pile. This pattern not only better organized the code but also enabled undo functionality. I refactored the code to reduce dependencies between modules. I created more defined card states (IDLE, MOUSE_OVER, GRABBED) and implemented a more organized approach to handling these states. I moved button handling and UI elements into their own classes, making the main game logic easier to follow and maintain. I addressed the hardcoded values issue by defining constants at the top of relevant files (like CARD_WIDTH, CARD_HEIGHT, VERTICAL_SPACING) to improve maintainability. This made layout changes easier to manage and improved code maintainability.


Sprites: https://kenney.nl/assets/boardgame-pack
Draw SFX: https://pixabay.com/sound-effects/flipcard-91468/
Shuffle SFX: https://pixabay.com/sound-effects/shuffle-92719/
Win SFX: https://pixabay.com/sound-effects/success-1-6297/




